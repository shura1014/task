package cron

import (
	"log"
	"regexp"
)

// 秒（Seconds）		, - * / 四个字符
// 分（Minutes）		, - * / 四个字符
// 小时（Hours）		, - * / 四个字符
// 日期（DayofMonth）,- * / ? L W C 八个字符
// 月份（Month） 	, - * / 四个字符
// 星期（DayofWeek） , - * / ? L C # 八个字符
// , 表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。
// - 表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次。
// * 表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。
// / 表示步长，在初始值后累加一次步长触发一次。例如在Minutes域使用5/20,则意味着在5分钟时触发一次，而5+20分钟，5+20+20分钟等分别触发一次。
// ? 只能用在DayofMonth和DayofWeek两个域。表示不关注该域，防止DayofMonth和DayofWeek会相互影响。例如：* * * 20 * ?, 表示任务设置在每月的20日触发调度，不管20日到底是星期几都会触发，而如果把？换成 *，则表示不管星期几都会触发调度, 而DayofMonth又设置为20，表示只能在每个月的20日触发调度，这样就会引起冲突，所以必须要对其中一个设置? 来表示并不关心它为何值。
// L 表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。
// W 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。
// LW 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。
// # 用于确定每个月第几个星期几，只能出现在DayofWeek域。例如在4#2，表示某月的第二个星期三。
// C 字符“C”允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历”关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历”中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）使用较少
var regexpCron = `^([\-/\d\*\?,]+)\s+([\-/\d\*\?,]+)\s+([\-/\d\*\?,]+)\s+([\-/\d\*\?,]+)\s+([\-/\d\*\?,A-Za-z]+)\s+([\-/\d\*\?,A-Za-z]+)$`
var cronReg *regexp.Regexp

func init() {
	reg, err := regexp.Compile(regexpCron)
	if err != nil {
		log.Panic(err)
	}
	cronReg = reg
}

// Parse 每一个（）表示一个匹配组
func Parse(src string) []string {
	if cronReg == nil {
		log.Panic("cronReg init failed")
	}
	return cronReg.FindStringSubmatch(src)
}
